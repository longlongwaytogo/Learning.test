#OpenGL矩阵定义：
float  m[16];
### OpenGL中的矩阵是这样的：

	| 	m[0]  m[4]  m[8]   m[12]  |   
	| 	m[1]  m[5]  m[9]   m[13]  | 
	|	m[2]  m[6]  m[10]  m[14]  | 
	| 	m[3]  m[7]  m[11]  m[15]  | 
### 对它定义的坐标系，OpenGL是这么说的：  

		x轴向量(m[0], m[1], m[2]);
		y轴向量(m[4], m[5], m[6]);
		z轴向量(m[8], m9], m[10]);
		原点(m[12], m[13], m[14]);

### 乘法是这样的：  
		
		x'  = m[0]*x   + m[4]*y   +m[8]*z   + m[12]*w;
		y'  = m[1]*x   + m[5]*y   +m[9]*z   + m[13]*w;
		z'  = m[2]*x   + m[6]*y   +m[10]*z  + m[14]*w;
		w'  = m[3]*x   + m[7]*y   +m[11]*z  + m[15]*w;


 在OpenGL中4x4的矩阵用包含16个浮点数值的一维数组来表示，而不是用二维的4x4的数组来表示。OpenGL之所以这么做，因为使用一维数组更高效。当然OpenGL也支持二维数组的表示方式。而且要特别注意的是在矩阵中是使用列主序遍历数组的，即按列逐个遍历数组中的元素。


###加载矩阵
你可以使用下面的两个函数来加载你的列主序的矩阵到投影矩阵，模型视图矩阵或者纹理矩阵栈中。

glLoadMatrixf(GLfloat* m);

glLoadMatrixd(GLdouble* m);

绝大多数的OpenGL的实现是使用单精度的浮点数来计算管道中的数据的。使用双精度的形式会带来一定的性能开销。

下面的代码相当于调用glLoadIdentity函数。

		// 加载单位矩阵
		GLfloat m[] = 
		{ 1.0f, 0.0f, 0.0f, 0.0f,       // X 列
		0.0f, 1.0f, 0.0f, 0.0f,     	// Y 列
		0.0f, 0.0f, 1.0f, 0.0f,      	// Z 列
		0.0f, 0.0f, 0.0f, 1.0f };    	// 平移列
		glMatrixMode(GL_MODELVIEW);
		glLoadMatrixf(m);

相对应的OpenGL还提供了加载行主序的矩阵的两个函数

		void glLoadTransposeMatrixf(GLfloat *m);
		
		void glLoadTransposeMatrixd(GLdouble *m);







reference：
[http://blog.csdn.net/kasteluo/article/details/76946414](http://blog.csdn.net/kasteluo/article/details/76946414)  
[http://www.cnblogs.com/dragon2012/p/5147382.html](http://www.cnblogs.com/dragon2012/p/5147382.html)

____________________________________________________________________________________________________


左乘定义：
向量C经过矩阵M,变换为：C'.
 C' = M * C 
则，叫作 C 左乘 M
或：
左乘：高等代数中，用到两个矩阵相乘的时候，矩阵B×矩阵A，那么就称为A左乘以B（A是主语，B是宾语）。
说简单点,左乘(又称前乘)就是乘在左边（即乘号前）,右乘（又称后乘）就是乘在右边（即乘号后）.
比如说,A左乘E即AE
矩阵计算形式：
行计算
{  a1, a2, a3, a4,
   a5, a6, a7, a8,
   a9, a10,a11,a12，
   a13,a14,a15,a16
}
[a13,a14,a15,a16] 表示translate向量

列计算
{  a1, a5, a9, a13,
   a2, a6, a10, a14,
   a3, a7, a11, a15，
   a4, a8, a12, a16
}
[a13,a14,a15,a16] 表示translate向量

引擎	  矩阵计算形式				矩阵存储类型  向量类型   相乘方式   坐标系统  向上轴
CryEngine 	 列						行主序矩阵    	列向量     左乘       右手系     +z
OpenGL    	 列						列主序矩阵    	列向量	   左乘		  右手系     +y
Dirext	  							行主序矩阵		行向量	   右乘	      左手系
OSG		  							行主序矩阵		行向量	   右乘		  右手系 	 +z
Ogre 	  							行主序矩阵  	列向量	   左乘		  右手系     +y
Unity3D



1.什么是左乘，什么是右乘？

　　所谓左/右乘，是指参与运算的两个因子（向量、矩阵）在运算中的相对位置（主语相对宾语的位置），A左乘B即A*B，A右乘B即B*A。因此说左/右乘时，必须指定参与运算的两个因子才是有意义的，有时会省略主语（甚至同时省略主语和宾语），如在OSG中对顶点应用矩阵变换时，使用的是右乘（P*M），完整的说应该是矩阵M右乘向量P；而OpenGL对顶点进行矩阵变换，是使用左乘，即矩阵左乘向量P（M*P）。
　　左乘也叫做pre-multiply（A.premult(B)==B*A，即B左乘A），右乘也叫做post-multiply（A.postmult(B)==A*B，即B右乘A）。 
　　引用一位网友的解释：左乘就是从左边过来乘，对于A.premult(B)，就是参数B要从左边乘过来，即B左乘A，即A.premult(B)==B*A。 

2.什么是列主序，什么是行主序？
　　所谓矩阵的列主序和行主序，是指用一维数组存储二维矩阵元素的时候，是以第一列、第二列的顺，还是以第一行、第二行的顺序。因此，矩阵的主序只是存储（以一维数组传递数据）上的不同，在计算和使用中所代表的数学意义没有任何区别。
C语言中的二维数组a[4][4]，可以看作一个4*4的矩阵，并且它是按行主序存储的。因此，在使用列主序矩阵时(行主序吧，是不是写错了？)，可以直接把C语言二维数组作为矩阵使用。
　　OpenGL中使用列主序矩阵。由于矩阵主序对矩阵的数学意义没有任何影响，因此，说OpenGL使用列主序矩阵，实际上是指在向OpenGL传递矩阵数据时，用来存储矩阵元素的一维数组，是按照列主序定义的！即glLoadMatrix要求的传入参数是按列主序定义的矩阵。
[http://www.cnblogs.com/indif/archive/2011/05/13/2045098.html](http://www.cnblogs.com/indif/archive/2011/05/13/2045098.html)