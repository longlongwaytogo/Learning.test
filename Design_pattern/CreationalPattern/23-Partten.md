# 23 种设计模式：

## 创建型：
- Factory Methord   工厂方法模式  
- Abstract Factory  抽象工厂模式
- Singleton			单例模式
- Builder			建造者模式
- Prototype			原型模式

## 结构型
- Bridge		桥接模式
- Adapter		适配器模式
- Decorator		装饰模式 
- Composite		组合模式
- Flyweight		享元模式
- Facade		外观模式
- Proxy			代理模式

## 行为模式
- Template      模版模式
- Strategy		策略模式
- State			状态模式
- Observe		观察者模式
- Memento		备忘录模式
- Mediator		中介者模式
- Command		命令模式
- Visitor		访问者模式
- Chain of Responsibility 责任链模式
- Iterator				  迭代器模式
- Inerpreter			  解析器模式




## 面向对象设计的SOLID原则

S.O.L.I.D是面向对象设计和编程(OOD&OOP)中几个重要编码原则(Programming Priciple)的首字母缩写。

### SRP	The Single Responsibility Principle [单一责任原则]
	让一个类只做一种类型责任，当这个类需要承当其他类型的责任的时候，就需要分解这个类。 
### OCP	The Open Closed Principle 			[开放封闭原则]
	软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。

	理解：类、模块、函数，可以去扩展，但不要去修改。如果要修改代码，尽量用继承或组合的方式来扩展类的功能，而不是直接修改类的代码。当然，如果能保证对整个架构不会产生任何影响，那就没必要搞的那么复杂，直接改这个类吧。

总结：对软件实体的改动，最好用扩展而非修改的方式。
### LSP	The Liskov Substitution Principle	[里氏替换原则]
	当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有is-A关系 
	总结：在继承类是，务必重写（override）父类中所有的方法，尤其需要注意父类的protected方法（它们往往是让你重写的），子类尽量不要暴露自己的private方法供外界调用。
### DIP	The Dependency Inversion Principle	[依赖倒置原则]

	1. 高层模块不应该依赖于低层模块，二者都应该依赖于抽象 
	2. 抽象不应该依赖于细节，细节应该依赖于抽象 
	3. 总结：面向接口编程，提取出事务的本质和共性。

### ISP	The Interface Segregation Principle	[接口分离原则]

	定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。
	问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。

	解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。
### 最少知识原则
	理解：尽量减少对象之间的交互，从而减小类之间的耦合。在做系统设计时，不要让一个类依赖于太多其他的类，需尽量减小依赖关系，否则死都不知道怎么死的。

	总结：一定要做到：低耦合、高内聚。


## 装饰模式、装饰器模式、代理模式、外观模式区别
	记住JAVA设计模式的基本原则，对内关闭修改
 
概念：
适配器模式，一个适配允许通常因为接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。


装饰器模式，原有的不能满足现有的需求，对原有的进行增强。


代理模式，同一个类而去调用另一个类的方法，不对这个方法进行直接操作。


外观模式，我们通过外观的包装，使应用程序只能看到外观对象，而不会看到具体的细节对象，这样无疑会降低应用程序的复杂度，并且提高了程序的可维护性。


区别：
代理模式是与原对象实现同一个接口，必须要实现原接口和持有真实的对象，才能称之为代理类。代理模式一定是自身持有这个对象，不需要从外部传入。用代理模式，代理类可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。


装饰模式的一定是从外部传入，并且可以没有顺序，按照代码的实际需求随意挑换顺序。当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。


适配器类则是匹配新接口，从代码上的特点来说，适配类持有新的目标对象（对象适配器）。


代理模式注重的是隔离限制，关注于控制对对象的访问，让外部不能访问你实际的调用对象，比如权限控制。代理和真实对象之间的的关系通常在编译时就已经确定了。
装饰模式注重的是功能的拓展，关注于在一个对象上动态的添加方法，在同一个方法下实现更多的功能。装饰者能够在运行时递归地被构造。 
适配器模式注重的是接口的兼容。 
外观模式注重的是多个类的集成、统一适配。
--------------------- 
作者：zhang31jian 
来源：CSDN 
原文：https://blog.csdn.net/zhang31jian/article/details/50538000 
版权声明：本文为博主原创文章，转载请附上博文链接！